package trees
package cgtree

import core.*
import chain.*
import chain.demo.*
import org.apache.commons.text.StringEscapeUtils
import trees.ast.*

import scala.annotation.tailrec

// Scala code generator for the AST interpretation.
class CGTreeToScala extends CGTreeVisitorBase:
  private object Helpers:
    def gen_type_brackets(types: Tys, ctx: Ctx): Unit =
      @tailrec
      def gen(types: Tys, cw: SourceCodeWriter): String =
        types match
          case Nil => cw.get_code()
          case ty :: tail =>
            val ty_str = ty_to_str(ty.untag)
            cw.write_code(ty.untag.repr)
            if tail.nonEmpty then cw.write_code(", ")
            gen(tail, cw)
      end gen

      if types.nonEmpty then
        ctx.write_code("[")
        val code = gen(types, new SourceCodeWriter())
        ctx.write_code(code)
        ctx.write_code("]")
      end if
    end gen_type_brackets

    def get_module_package(writer: SourceCodeWriter): CGTree =
      writer.write_code_ln("package generated")
      writer.write_comment(" Code is generated by the CGTree compiler")
      writer.write_ln()

      CGTree.PrimCodeT(writer.get_code())
    end get_module_package

    def get_module_prim_imports(writer: SourceCodeWriter): CGTree =
      //writer.write_code_ln("import core.*")
      //writer.write_code_ln("import chain.*")

      CGTree.PrimCodeT(writer.get_code())
    end get_module_prim_imports

    val Str_Map = classOf[scala.collection.immutable.Map[?, ?]].getCanonicalName
    val Str_Set = classOf[scala.collection.immutable.Set[?]].getCanonicalName
    val Str_Seq = classOf[scala.collection.immutable.IndexedSeq[?]].getCanonicalName

    // Read a file from the source code. The need for this is to use the exact code we use here
    // as part of the Scala CGTree compiler code for primitives.
    //
    // Note This way of doing things is obviously a hack but it works from both the IDE and the sbt
    //      console (for the latter, launch it from the project's top folder after a git checkout).
    // 
    def read_src_file(file: String): String =
      val contents = scala.io.Source.fromFile(file)
        .getLines()
        .drop(1) // drop "package" statement
        .mkString("\n")

      contents
    end read_src_file

    def get_module_prim_types_and_data(writer: SourceCodeWriter): CGTree =
      val src_folder = "src/main/scala/core/"
      val src_files = List(
        "types.scala",
        "types_int.scala",
      )
      
      for file <- src_files do
        val code = read_src_file(src_folder + file)
        writer.write_code_ln(code)
        writer.write_ln()
      end for
      
      CGTree.PrimCodeT(writer.get_code())
    end get_module_prim_types_and_data

    def get_prim_funs(writer: SourceCodeWriter): CGTree =
      val new_writer = writer.new_with_same_indentation()
      val pf_visitor = new PrimFunToScala

      for pf <- PrimFun.values do
        pf_visitor.visit(pf, new_writer)
      end for

      CGTree.PrimCodeT(new_writer.get_code())
    end get_prim_funs

  end Helpers

  import Helpers.*

  def get_module_preamble(writer: SourceCodeWriter): CGTrees =
    val buffer = new CGTreeBuffer

    // this implementation proposes an organization for the preamble

    val pkg_decl = get_module_package(writer.new_with_same_indentation())
    buffer.add_tree(pkg_decl)

    val imports = get_module_prim_imports(writer.new_with_same_indentation())
    buffer.add_tree(imports)

    buffer.add_tree(CGTree.CommentT("Primitive types, data, and functions"))
    buffer.add_tree(CGTree.CommentT("These are provided by the code generator"))
    val types_and_data = get_module_prim_types_and_data(writer.new_with_same_indentation())
    buffer.add_tree(types_and_data)

    val functions = get_prim_funs(writer.new_with_same_indentation())
    buffer.add_tree(functions)

    buffer.get_trees()
  end get_module_preamble

  def write_comment(writer: SourceCodeWriter, comment: String): Unit =
    CodeGenHelpers.write_Scala_comment(writer, comment)
  end write_comment

  def write_name_and_type(writer: SourceCodeWriter, name: String, ty: String): Unit =
    if name.endsWith("_") then
      writer.write_code(s"$name : $ty") // Scala does not like an _ before an :
    else
      writer.write_code(s"$name: $ty")
    end if
  end write_name_and_type

  def write_function_params(writer: SourceCodeWriter, params: NameTypes): Unit =
    @tailrec
    def inner(writer: SourceCodeWriter, params: NameTypes): Unit =
      // Note If you write this as a pattern match on `params`, then compiler cannot consider the last call
      //      as a tail call.
      //      Hence the `if`, and we pattern match on the non-`Nil` case with the destructuring `val`.
      if params.nonEmpty then
        val param :: tail = params
        writer.write_name_and_type(param)
        if tail.nonEmpty then writer.write_code(", ")
        inner(writer, tail)
      end if
    end inner
    
    inner(writer, params)
  end write_function_params

  def write_function_params_and_ret_ty(writer: SourceCodeWriter, params: NameTypes, ret_ty: Ty[?]): Unit =
    val ret_ty_str = ty_to_str(ret_ty)

    writer.write_code("(")
    write_function_params(writer, params)
    writer.write_code(s"): $ret_ty_str")
  end write_function_params_and_ret_ty

  def ty_to_str(ty: Ty[?]): String =
    inline def tts(ty: Ty[?]): String = ty_to_str(ty)

    // TODO move these fixed strings elsewhere, other languages could use the same.
    ty match
      case Ty.UnitTy   => "Unit" // "()"
      case Ty.NatTy    => "Nat"
      case Ty.ZatTy    => "Zat"
      case Ty.BoolTy   => "Bool"
      case Ty.StringTy => "String"
      case Ty.CharTy   => "Char"

      case Ty.RTy(inner) => tts(inner)

      case Ty.Fun0Ty(to)       => s"() => ${tts(to)}"
      case Ty.Fun1Ty(a, z) => s"${tts(a)} => ${tts(z)}"
      case Ty.Fun2Ty(a, b, z) => s"(${tts(a)}, ${tts(b)}) => ${tts(z)}"
      case Ty.Fun3Ty(a, b, c, z) => s"(${tts(a)}, ${tts(b)}, ${tts(c)}) => ${tts(z)}"
      case Ty.Fun4Ty(a, b, c, d, z) => s"(${tts(a)}, ${tts(b)}, ${tts(c)}, ${tts(d)}) => ${tts(z)}"
      case Ty.Fun5Ty(a, b, c, d, e, z) => s"(${tts(a)}, ${tts(b)}, ${tts(c)}, ${tts(d)}, ${tts(e)}) => ${tts(z)}"

      case Ty.OptionTy(a)    => s"Option[${tts(a)}]"
      case Ty.PairTy(a, b)   => s"Pair[${tts(a)}, ${tts(b)}]"

      case Ty.MapTy(a, b) => s"Map[${tts(a)}, ${tts(b)}]"
      case Ty.SetTy(a)    => s"Set[${tts(a)}]"
      case Ty.SeqTy(a)    => s"Seq[${tts(a)}]"

      case Ty.StructTy(tag)  =>
        val StructSuffix = "Struct"
        val name = tag.runtimeClass.getSimpleName
        if name.endsWith(StructSuffix) then name.substring(0, name.length - StructSuffix.length) else name

      case Ty.PropTy() => s"Prop"
  end ty_to_str

  def binop_to_str(op: BinOp): String = binop_default_repr(op)

  def unaryop_to_str(op: UnaryOp): String = unaryop_default_repr(op)

  def visit_LiteralExprT(tree: CGTree.LiteralExprT, ctx: Ctx): Result =
    tree.value match
      case Literal.BoolLit(value) =>
        // booleans are represented as they are
        ctx.write_code(value.toString)
      case Literal.NatLit(value) =>
        ctx.write_code(s"${PrimFun.Nat.identifier}(")
        ctx.write_code(value.v.toString())
        ctx.write_code(")")
      case Literal.ZatLit(value) =>
        ctx.write_code(s"${PrimFun.Zat.identifier}(")
        ctx.write_code(value.v.toString())
        ctx.write_code(")")
      case Literal.StringLit(value) =>
        val escaped = StringEscapeUtils.escapeJava(value)

        ctx.write_code("\"")
        ctx.write_code(escaped)
        ctx.write_code("\"")
      case Literal.CharLit(value) =>
        val escaped = StringEscapeUtils.escapeJava(value.toString)

        ctx.write_code("'")
        ctx.write_code(escaped)
        ctx.write_code("'")
    end match
  end visit_LiteralExprT

  def visit_RefExprT(tree: CGTree.RefExprT, ctx: Ctx): Result =
    ctx.write_code(tree.bind_t.name)
  end visit_RefExprT

  def visit_BinOpExprT(tree: CGTree.BinOpExprT, ctx: Ctx): Result =
    ctx.write_code("(")
    visit(tree.a, ctx)
    val bin_op = binop_to_str(tree.op)
    ctx.write_code(s" $bin_op ")
    visit(tree.b, ctx)
    ctx.write_code(")")
  end visit_BinOpExprT

  def visit_UnaryOpExprT(tree: CGTree.UnaryOpExprT, ctx: Ctx): Result =
    val unary_op = unaryop_to_str(tree.op)
    ctx.write_code(s" $unary_op ")
    ctx.write_code("(")
    visit(tree.a, ctx)
    ctx.write_code(")")
  end visit_UnaryOpExprT

  def visit_CallExprT(tree: CGTree.CallExprT, ctx: Ctx): Result =
    ////////
    // f[A, B, ...](arg, arg, ...)
    ///////

    visit(tree.f, ctx)
    gen_type_brackets(tree.types, ctx)

    def gen_args(args: CGTrees): Unit =
      args match
        case Nil =>
        case arg :: tail =>
          visit(arg, ctx)
          if tail.nonEmpty then ctx.write_code(", ")
          gen_args(tail)
    end gen_args

    ctx.write_code("(")
    gen_args(tree.args)
    ctx.write_code(")")
  end visit_CallExprT

  def visit_StructNewExprT(tree: CGTree.StructNewExprT, ctx: Ctx): Result =
    ctx.write_code(s"${tree.name}(")

    def write_fields(fields: NameCGTrees): Unit =
      fields match
        case Nil =>
        case NameCGTree(name, value) :: tail =>
          ctx.write_code(s"$name = ")
          visit(value, ctx)
          if tail.nonEmpty then ctx.write_code(", ")
          write_fields(tail)
      end match
    end write_fields

    write_fields(tree.fields)
    ctx.write_code(")")
  end visit_StructNewExprT

  def visit_DotExprT(tree: CGTree.DotExprT, ctx: Ctx): Result =
    visit(tree.prefix, ctx)
    ctx.write_code(".")
    ctx.write_code(tree.field.name)
  end visit_DotExprT

  def visit_IfThenElseExprT(tree: CGTree.IfThenElseExprT, ctx: Ctx): Unit =
    ctx.write_code("if ")
    visit(tree._if, ctx)
    ctx.write_code_ln(" then")
    ctx.with_indentation {
      //visit_trees(tree._then, ctx)
      visit(tree._then, ctx)
    }
    ctx.write_ln()
    ctx.write_code_ln("else")
    ctx.with_indentation {
      //visit_trees(tree._else, ctx)
      visit(tree._else, ctx)
    }
    ctx.write_ln()
    ctx.write_code_ln("end if")
  end visit_IfThenElseExprT

  def visit_ValDefT(tree: CGTree.ValDefT, ctx: Ctx): Result =
    ////////
    // [lazy] val name : type = value
    ///////

    if tree.is_lazy then ctx.write_code("lazy ")
    ctx.write_code("val ")
    ctx.write_name_and_type(tree.name_ty)
    ctx.write_code(" = ")
    visit(tree.value, ctx)
    ctx.write_ln()
  end visit_ValDefT

  def gen_prop(prop: CGProp, ctx: Ctx): Result =
    prop match
      case CGProp.BoolCGP(prop_is, prop_owner_name, prop_name, prop_index, prop_input, predicate) =>
        // Make a function and delegate to function code generation!
        val new_tree =
          CGTree.FunDefT(
            prop_name,
            prop_input,
            Ty.UnitTy,
            predicate,
            InlineIs.Inline,
            Nil,
            Nil
          )

        visit(new_tree, ctx)

      case CGProp.ForAllInRangeCGP(prop_is, prop_owner_name, prop_name, prop_index, prop_input, for_loop_deps, for_loop) =>
        val body = for_loop_deps appended for_loop

        val new_tree =
          CGTree.FunDefT(
            prop_name,
            prop_input,
            Ty.UnitTy,
            body,
            InlineIs.Inline,
            Nil,
            Nil
          )

        visit(new_tree, ctx)
    end match
  end gen_prop

  def gen_props(props: List[CGProp], prop_is: PropIs, f_name: String, ctx: Ctx): Unit =
    val label = prop_is.label

    val msg = s"${ label }-conditions for ${ f_name }"

    if props.nonEmpty then
      ctx.write_ln()
      ctx.write_comment(s"+ ${ msg }")
      for prop <- props do
        gen_prop(prop, ctx)
      end for
      ctx.write_comment_ln(s"- ${ msg }")
    end if
  end gen_props

  def visit_FunDefT(tree: CGTree.FunDefT, ctx: Ctx): Result =
    ////////
    // def name(param: type, param: type,  ...): ret_type =
    //   body ...
    // end name // (param: type, param: type,  ...): ret_type
    ///////

    val CGTree.FunDefT(name, params, ret_ty, body, inline_is, pre_cond, post_cond) = tree

    ctx.write_ln()
    if inline_is == InlineIs.Inline then ctx.write_code("inline ")
    ctx.write_code(s"def $name")
    ctx.write_function_params_and_ret_ty(params, ret_ty)
    ctx.write_code_ln(s" = ")
    ctx.with_indentation {
      for tree <- body do
        visit(tree, ctx)
      end for
      ctx.write_ln()
    }
    ctx.write_code(s"end $name ")
    ctx.write_comment("")
    ctx.write_function_params_and_ret_ty(params, ret_ty)
    ctx.write_ln()

    gen_props(pre_cond,  PropIs.PreCondition,  name, ctx)
    gen_props(post_cond, PropIs.PostCondition, name, ctx)
  end visit_FunDefT

  def visit_LambdaDefT(tree: CGTree.LambdaDefT, ctx: Ctx): Result =
    // TODO implement
    ctx.write_comment_ln(s" ${tree}")
  end visit_LambdaDefT


  def visit_StructDefT(tree: CGTree.StructDefT, ctx: Ctx): Result =
    val CGTree.StructDefT(name, fields) = tree

    ctx.write_code_ln(s"case class $name(")

    def write_fields(fields: NameTypes): Unit =
      fields match
        case Nil =>
        case field :: tail =>
          ctx.write_name_and_type(field)
          if tail.nonEmpty then ctx.write_code_ln(",")
          write_fields(tail)
    end write_fields

    ctx.with_indentation {
      write_fields(fields)
    }

    ctx.write_ln()
    ctx.write_code_ln(")")
    ctx.write_ln()
  end visit_StructDefT

  def visit_PrimCodeT(tree: CGTree.PrimCodeT, ctx: Ctx): Unit =
    ctx.write_raw_str(tree.code)
  end visit_PrimCodeT

  def visit_CommentT(tree: CGTree.CommentT, ctx: Ctx): Result =
    ctx.write_comment_ln(tree.comment)
  end visit_CommentT
  
  def visit_ForLoopT(tree: CGTree.ForLoopT, ctx: Ctx): Unit =
    ctx.write_comment_ln(s" ${ tree }")
    ctx.write_code(s"for ${ tree.name } <- ")
    visit(tree.lower, ctx)
    tree.upper_bound_is match
      case BoundIs.Inclusive => ctx.write_code(" to ")
      case BoundIs.Exclusive => ctx.write_code(" until ")
    end match
    visit(tree.upper, ctx)
    ctx.write_code_ln(" do")
    ctx.with_indentation {
      visit_trees(tree.body, ctx)
    }
    ctx.write_code_ln("end for")
  end visit_ForLoopT

  def gen_require_ensure(verb: String, tree: CGTree, ctx: Ctx) =
    val new_ctx = ctx.new_with_same_indentation()
    ctx.write_code_ln(s"$verb(")

    visit(tree, new_ctx)
    val code = new_ctx.get_code()
    ctx.write_code(code)

    ctx.write_code_ln(",")

    // And since we are programming at the meta level, we have the _actual_ expression at our disposal,
    // so why not provide it in the error message as useful context ? :-D
    val new_ctx2 = ctx.new_with_same_indentation()
    val trimmed_code = code.trim
    val parenthesized_code = if trimmed_code.startsWith("(") then trimmed_code else s"($trimmed_code)"
    val msg = StringEscapeUtils.escapeJava(s"$verb${parenthesized_code}")
    new_ctx2.write_code(s"\"$msg\"")
    ctx.write_code_ln(new_ctx2.get_code())

    ctx.write_code_ln(")")
  end gen_require_ensure

  def visit_RequireT(tree: CGTree.RequireT, ctx: Ctx): Unit =
    gen_require_ensure(PrimFun.Require.identifier, tree.tree, ctx)
  end visit_RequireT

  def visit_EnsureT(tree: CGTree.EnsureT, ctx: Ctx): Unit =
    gen_require_ensure(PrimFun.Ensure.identifier, tree.tree, ctx)
  end visit_EnsureT
end CGTreeToScala

val StdCodeGenBase: CodeGenBase = new CGTreeToScala

@main def cgtree_code_gen_demo(): Unit =
  val ast_chain = new ASTChain(DemoChainConfig)

  val structs  = ast_chain.Chain_Structs
  val bindings = ast_chain.Chain_BindTs

  val code_gen = new CGTreeToScala()
  val writer = SourceCodeWriter()
  val config = CodeGenConfig(logger = Logger().set_logging_off())

  CodeGenHelpers.gen_module(
    structs,
    bindings,
    code_gen,
    writer,
    config
  )

  val code = writer.get_code()

  println(code)
end cgtree_code_gen_demo
