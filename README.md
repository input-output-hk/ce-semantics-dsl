## Denotational semantics for the masses

Denotational semantics via tagless-final.
A comprehensive tagless-final library in Scala 3, with an application to blockchain ledgers. In particular we model parts of the Cardano Ledger.

From the abstract of the [paper](doc/report/report.pdf):

> We use a tagless-final approach to design an Embedded Domain-Specific Language (eDSL) and accompanying infrastructure for the specification and utilization of program semantics. Semantics defined in this way, for blockchain ledgers and other systems, are denotational, directly executable and amenable to multiple interpretations. We provide a layered compiler supported by two families of Abstract Syntax Trees (AST), the former as a direct translation of eDSL-based semantics and the latter suitable for immediate code generation. In addition, we provide a code generator for the Scala programming language as a backend for the compiler. Our design is in Scala, without relying on exotic features like macros or staging. We use the logic of Scala's implicits to encode algorithmic type reconstruction rules in a straightforward way, lifting the compiler's type computations at the value level, thus enabling powerful type-preserving code generation from the eDSL. We observe that we can support recursion directly, without resorting to the usual _fixpoint_ combinators, by letting the compiler tie the knot. As a consequence of this and other design choices, the computations written using our approach are close to what a software engineer would write without thinking about "semantics" or using "too theoretical artifacts". Thus we deliberately try to bridge the gap between software engineering and formal methods and we provide a methodology for teams with different mindsets to collaborate effectively. The design space is vast but the current results are tangible and our hope is that by exploring it further we can reap many more benefits, helping making "semantics programming" more mainstream. The code is the spec is the code.
