package chain


import core.*

/////////////////////////////////////////////////////////////
//// Sec.8.1, p.21 ledger-spec
//// As a first example, we implement semantics for the UTxO transitions.
//// Work in progress
/////////////////////////////////////////////////////////////
trait UTxOSystem[R[_]] extends ChainTransitionSystem[R]:
  import TypeInference.given

  ////////////////
  // Inputs
  //          Note: All inputs become visible to the transition computations, and so they are available
  //                to predicates.
  //                In essence, if a transition is represented by a function, then the inputs would be
  //                defined as the function arguments.
  //          Note: Here, the function is the constructor
  //
  // Signal: Tx
  //          Note: Emitted by what?
  // Input: tx: I[Tx]
  //          Note: Does the signal carry the tx data? If not where do I get the tx from?
  //          Note: In general, do signals carry data? In ledger-spec they do not.
  // Input: utxoenv:   UTxOEnv
  // Input: utxostate: UTxOState
  final class UTxOSystem(
    val impl_signal:    R[Signal],
    val impl_tx:        R[Tx],
    val impl_utxoenv:   R[UTxOEnv],
    val impl_utxostate: R[UTxOState],
  ) extends SystemSkeleton:
    system =>

    // Make the provided input parameters available as variables to the AST interpreter.
    val signal    = v["signal"]    := impl_signal
    val tx        = v["tx"]        := impl_tx
    val utxoenv   = v["utxoenv"]   := impl_utxoenv
    val utxostate = v["utxostate"] := impl_utxostate
    
    def System_Input_Binds = List(
      signal,
      tx,
      utxoenv,
      utxostate
    )

    // fig.14, p.22 ledger-spec
    // Tx outputs as UTxO
    //////////////// Sec 8.1
    // The function outs creates unspent outputs generated by a transaction, so that they can be
    // added to the ledger state. For each output in the transaction, outs maps the transaction id
    // and output index to the output.
    // TODO Is it a TxBody or a Tx?
    protected def impl_outs(tx: R[TxBody]): R[UTxO] =
      Todo("implement", map_new())
    end impl_outs

    lazy val outs = f["outs"] := p["txbody"] --> impl_outs


    // fig.14, p.22 ledger-spec
    // UTxO balance
    //////////////// Sec 8.1
    // The ubalance function calculates sum total of all the coin in a given UTxO
    protected def impl_ubalance(utxo: R[UTxO]): R[Coin] =
      val coin_mapper = f["coin_mapper"] :=
        p["txout"] --> ( (txout: R[TxOut]) => txout.get(TxOut.coins) )

      val txout_seq: R[Seq[R[TxOut]]] = utxo.values()
      val coin_seq:  R[Seq[R[Coin]]]  = txout_seq.map(coin_mapper)
      val coin_sum:  R[Coin]          = coin_seq.sum(coin_zero, coin_add)

      coin_sum
    end impl_ubalance

    lazy val ubalance = f["ubalance"] := p["utxo"] --> impl_ubalance

    // fig.14, p.22 ledger-spec
    // Withdrawal balance
    //////////////// Sec 8.1
    // The wbalance function calculates the total sum of all the reward withdrawals in a
    // transaction.
    protected def impl_wbalance(wdrl: R[Wdrl]): R[Coin] =
      val coin_seq: R[Seq[R[Coin]]] = wdrl.values()
      val coin_sum: R[Coin]         = coin_seq.sum(coin_zero, coin_add)

      coin_sum
    end impl_wbalance

    lazy val wbalance = f["wbalance"] := p["wdrl"] --> impl_wbalance

    // fig.14, p.22 ledger-spec
    // value consumed
    //////////////// Sec 8.1
    // The calculation consumed gives the value consumed by the transaction tx in the context
    // of the protocol parameters, the current UTxO on the ledger and the registered stake
    // credentials. This calculation is a sum of all coin in the inputs of tx, reward withdrawals
    // and stake credential deposit refunds. Some of the definitions used in this function will be
    // defined in Section 8.2. In particular, keyRefunds is defined in Figure 17.
    protected def impl_consumed(pparams: R[PParams], utxo: R[UTxO], txbody: R[TxBody]): R[Coin] =
      Todo("implement", coin_zero)
    end impl_consumed

    lazy val consumed = f["consumed"] := (p["pparams"], p["utxo"], p["txbody"]) --> impl_consumed

    // fig.14, p.22 ledger-spec
    // value produced
    //////////////// Sec 8.1
    // The calculation produced gives the value produced by the transaction tx in the context of
    // the protocol parameters and the registered stake pools. This calculation is a sum of all coin
    // in the outputs of tx, the transaction fee and all needed deposits. Some of the definitions
    // used in this function will be defined in Section 8.2. In particular, totalDeposits is defined in
    // Figure 17.
    protected def impl_produced(pparams: R[PParams], kp: R[R[KeyHash_Pool] => R[PoolParam]], txbody: R[TxBody]): R[Coin] =
      Todo("implement", coin_zero)
    end impl_produced

    lazy val produced = f["produced"] := (p["pparams"], p["kp"], p["txbody"]) --> impl_produced

    // fig.17, p.16 ledger-spec
    //////////////// Sec 8.2
    // The function keyRefunds, calculates the total amount of returned deposits from stake key
    //  deregistration certificates.
    // Note that keyRefunds uses the current protocol parameters. This means that any deposits
    //  made prior to a change in the deposit values will be refunded with the current value, not
    //  the one originally paid.
    protected def impl_key_refunds(pparams: R[PParams], txbody: R[TxBody]): R[Coin] =
      Todo("implement", coin_of_n(N_0))
    end impl_key_refunds

    lazy val key_refunds = f["key_refunds"] := (p["pparams"], p["txbody"]) --> impl_key_refunds

    // p.23 ledger-spec.pdf
    //def signals = set_of_elem(signal_new_Tx)

    ////////////////
    // Transition: UTxO-inductive
    ////////////////

    ////////////////
    // Definitions (let bindings) before the predicates are evaluated.
    //  These are inputs for the predicates.
    //  Note: They can be thought of like local variables to the transition computation.
    //
    // Binding: txb := txbody tx
    lazy val txb = v["txb"] := tx.get(Tx.body)

    // Helper binding
    // Not defined in spec but used, eg see the `txttl txb ≥ slot` predicate below)
    // Note that we use attribute selection via the dot '.'. In an AST we would represent this
    //  as a SelectField() constructor.
    lazy val slot = v["slot"] := utxoenv.get(UTxOEnv.slot)

    ////////////////
    // Premise Predicate: The transaction is live (the current slot is less than its time to live)
    //
    // Condition: txttl txb ≥ slot
    //
    // Failure: Expired
    protected def impl_pred_tx_is_live(): R[Bool] =
      txbody_get_ttl(txb) >= slot
    end impl_pred_tx_is_live

    lazy val pred_tx_is_live = f["pred_tx_is_live"] := fun0(impl_pred_tx_is_live)

    lazy val premise_tx_is_live = v["premise_tx_is_live"] := premise_new(pred_tx_is_live, PredError_Expired)
    
    ////////////////
    // Premise Predicate: The transaction has at least one input. The global uniqueness of transaction inputs
    //  prevents replay attacks. By requiring that all transactions spend at least one input, the
    //  entire transaction is safe from such attacks. A delegation certificate by itself, for example,
    //  does not have this property.
    //
    // Condition: txins txb != ∅
    //
    // Failure: InputSetEmpty, to prevent replay attacks

    ////////////////
    // Premise Predicate: The fee paid by the transaction has to be greater than or equal to the minimum fee, which
    //  is based on the size of the transaction. A user or wallet might choose to create a fee larger
    //  than necessary in exchange for a faster processing time.
    //
    // Condition: minfee pp tx ≤ txfee txb
    //
    // Failure: FeeTooSmall

    ////////////////
    // Premise Predicate: Each input spent in the transaction must be in the set of unspent outputs.
    //
    // Condition: txins txb ⊆ dom utxo
    //
    // Failure: FIXME No Failure defined in ledger-spec for this predicate (at least not in the right place,
    //          where all other failures of the UTxO transition are listed)

    ////////////////
    // Premise Predicate: The preservation of value property must hold. In other words, the amount of value produced
    //  by the transaction must be the same as the amount consumed.
    //
    // Condition: consumed pp utxo txb = produced pp poolParams txb
    //
    // Failure: ValueNotConserved


    ////////////////
    // Premise Predicate: The PPUP transition is successful.
    //
    // Condition:
    // [ slot      ]          txup tx
    // [  pp       ] ⊢ ppup ----------> ppup'
    // [ genDelegs ]           PPUP
    //
    // Failure: Note: implied failure(s) from the PPUP transition

    ////////////////
    // Premise Predicate: The coin value of each new output must be at least as large as the minimum value specified
    //  by the protocol parameter minUTxOValue.
    //
    // Condition: ∀(_ ↦ (_, c)) ∈ txouts txb, c ≥ (minUTxOValue pp)
    //
    // Failure: OutputTooSmall


    ////////////////
    // Premise Predicate: FIXME There is no description for this in ledger-spec
    // (Note: derived predicate description) The bootstrap outputs have attributes of size less than
    // or equal to 64.
    //
    // Condition: ∀(_ ↦ (a, _)) ∈ txouts txb, a ∈ Addr bootstrap ⇒ bootstrapAttrsSize a ≤ 64
    //
    // Failure: OutputBootAddrAttrTooBig


    ////////////////
    // Premise Predicate: FIXME There is no description for this in ledger-spec
    // (Note: derived predicate description) The network id for all txouts is the actual NetworkId
    //
    // Condition: ∀(_ ↦ (a, _)) ∈ txouts txb, netId a = NetworkId
    //
    // Failure: WrongNetwork


    ////////////////
    // Premise Predicate: FIXME There is no description for this in ledger-spec
    // (Note: derived predicate description) The network id for all withdrawals is the actual NetworkId
    //
    // Condition: ∀(a ↦ _) ∈ txwdrls txb, netId a = NetworkId
    //
    // Failure: WrongNetworkWithdrawal


    ////////////////
    // Premise Predicate: The transaction size must be below the allowed maximum. Note that there is an implicit
    //  max transaction size given by the max block size, and that if we wished to allow a
    //  transaction to be as large as will fit in a block, this check would not be needed. Being
    //  able to limit the size below that of the block, however, gives us some control over how
    //  transactions will be packed into the blocks.
    //
    // Condition: txsize tx ≤ maxTxSize pp
    //
    // Failure: MaxTxSize


    ////////////////
    // Definitions (let bindings) after all the predicates are computed to hold.
    //  These are inputs for the transition itself.
    //

    ////////////////
    // Binding: refunded := keyRefunds pp txb
    // Note (error in spec): In fig.16, which the above definition comes from,
    //  `keyRefunds` uses `txb` but in fig.17, where `keyRefunds` is defined, it uses `tx`.
    //  But the type in fig.17 is the correct one (TxBody instead of Tx).
    //  Now, in general, fig. 10 seems to be problematic because there are functions defined
    //  over a Tx, instead of TxBody. See for instance `txcerts` in fig.10, which is defined
    //  over a Tx but is used for a TxBody in fig.17.

    ////////////////
    // Binding: depositChange := totalDeposits pp poolParams ( txcerts txb ) − refunded


    def System_Binds = List(
      outs,
      ubalance,
      wbalance,
      consumed,
      produced,
      key_refunds,
      txb,
      slot,
      pred_tx_is_live,
      premise_tx_is_live,
    )
    def System_Structs = Nil

    protected def impl_premises(): R[Seq[R[Premise]]] =
      seq_new(premise_tx_is_live)
    end impl_premises
  end UTxOSystem
end UTxOSystem
