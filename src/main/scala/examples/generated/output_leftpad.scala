package generated
// Code is generated by the CGTree compiler

//Primitive types, data, and functions
//These are provided by the code generator


type Bool   = scala.Boolean
type String = scala.Predef.String
type Unit   = scala.Unit
type Char   = scala.Char

type Name = String & Singleton // an identifier in the object language for which require a literal string

type Option[T]    = scala.Option[T]

type Pair[A, B] = (A, B)
type Map[K, V] = scala.collection.immutable.Map[K, V]
type Set[K] = scala.collection.immutable.Set[K]
type Seq[K] = scala.collection.immutable.IndexedSeq[K]

val Map = scala.collection.immutable.Map
val Set = scala.collection.immutable.Set
val Seq = scala.collection.immutable.IndexedSeq


import scala.collection.immutable.NumericRange

export Nats.*
export Zats.*

object Nats:
  opaque type Nat = BigInt

  object Nat:
    def apply(i: Int): Nat =
      scala.Predef.require(i >= 0)
      BigInt(i)
    end apply

    def apply(i: BigInt): Nat =
      scala.Predef.require(i >= 0)
      i
    end apply

    extension (n: Nat)
      def v: BigInt = n

      def until(end: Nat, step: Nat = Nat(1)): NumericRange.Exclusive[Nat] = NumericRange(n, end, step)(NatIntegral)
      def to   (end: Nat, step: Nat = Nat(1)): NumericRange.Inclusive[Nat] = NumericRange.inclusive(n, end, step)(NatIntegral)

      def to_Zat: Zat = Zat(n.v)

      def eq_op(that: Nat): Bool = n.v == that.v
      def ===(that: Nat): Bool = n.v eq_op that

      def lt_op(that: Nat): Bool = v.v >= that.v
      def <(that: Nat): Bool = v lt_op that

      def gteq_op(that: Nat): Bool = v.v >= that.v
      def >=(that: Nat): Bool = v gteq_op that

      def add_op(that: Nat): Nat = Nat(n.v + that.v)
      def +(that: Nat): Nat = v add_op that

      def sub_op(that: Nat): Nat = Nat(n.v - that.v)
      def -(that: Nat): Nat = v sub_op that

      def mul_op(that: Nat): Nat = Nat(n.v * that.v)
      def *(that: Nat): Nat = v mul_op that

      def div_op(that: Nat): Nat = Nat(n.v / that.v)
      def /(that: Nat): Nat = v div_op that
    end extension
  end Nat
end Nats

object Zats:
  opaque type Zat = BigInt

  object Zat:
    def apply(i: Int): Zat = BigInt(i)
    def apply(i: BigInt): Zat = i

    extension (n: Zat)
      def v: BigInt = n

      def until(end: Zat, step: Zat = Zat(1)): NumericRange.Exclusive[Zat] = NumericRange(n, end, step)(ZatIntegral)
      def to(end: Zat, step: Zat = Zat(1)): NumericRange.Inclusive[Zat] = NumericRange.inclusive(n, end, step)(ZatIntegral)

      def eq_op(that: Zat): Bool = n.v == that.v
      def ===(that: Zat): Bool = n.v eq_op that

      def lt_op(that: Zat): Bool = v.v >= that.v
      def <(that: Zat): Bool = v lt_op that

      def gteq_op(that: Zat): Bool = v.v >= that.v
      def >=(that: Zat): Bool = v gteq_op that

      def add_op(that: Zat): Zat = Zat(n.v + that.v)
      def +(that: Zat): Zat = v add_op that

      def sub_op(that: Zat): Zat = Zat(n.v - that.v)
      def -(that: Zat): Zat = v sub_op that

      def mul_op(that: Zat): Zat = Zat(n.v * that.v)
      def *(that: Zat): Zat = v mul_op that

      def div_op(that: Zat): Zat = Zat(n.v / that.v)
      def /(that: Zat): Zat = v div_op that
    end extension
  end Zat
end Zats

implicit val NatIntegral: Integral[Nat] = scala.math.Numeric.BigIntIsIntegral.asInstanceOf[Integral[Nat]]
implicit val ZatIntegral: Integral[Zat] = scala.math.Numeric.BigIntIsIntegral.asInstanceOf[Integral[Zat]]

inline def nat(i: scala.Int): Nat =
  scala.Predef.require(i >= 0)
  Nat(i)
end nat

inline def nat(i: scala.BigInt): Nat =
  scala.Predef.require(i >= 0)
  Nat(i)
end nat
inline def zat(i: scala.Int   ): Zat = Zat(i)
inline def zat(i: scala.BigInt): Zat = Zat(i)
inline def zat_of_nat(nat: Nat): Zat = nat.to_Zat
inline def str_len(s: String): Nat = nat(s.length)
inline def str_char_at(s: String, i: Nat): Char = s.charAt(i.v.intValue)
inline def str_concat(a: String, b: String): String = a + b
inline def char(c: scala.Char): Char = c
inline def char_to_str(c: scala.Char): String = c.toString
inline def char_eq(a: scala.Char, b: scala.Char): Boolean = a == b
inline def map_new[K, V](): Map[K, V] = Map()
inline def map_get[K, V](map: Map[K, V], key: K): V = map(key)
inline def map_put[K, V](map: Map[K, V], key: K, value: V): Map[K, V] = map.updated(key, value)
inline def map_values[K, V](map: Map[K, V]): Seq[V] = map.values.toIndexedSeq
inline def set_new[K](): Set[K] = Set()
inline def set_add[K](set: Set[K], item: K): Set[K] = set + item
inline def seq_new[K](items: K*): Seq[K] = Seq(items*)
inline def seq_add[K](seq: Seq[K], item: K): Seq[K] = seq appended item
inline def seq_map[K, L](seq: Seq[K], f: (K) => L): Seq[L] = seq map f
inline def seq_fold_left[K, L](seq: Seq[K], initial: L, f: (L, K) => L): L = seq.foldLeft[L](initial)(f(_, _))
inline def pair_new[A, B](a: A, b: B): Pair[A, B] = (a, b)
inline def pair_first[A, B](pair: Pair[A, B]): A = pair._1
inline def pair_second[A, B](pair: Pair[A, B]): B = pair._2
inline def require[A](condition: Boolean, message: =>A): Unit = scala.Predef.require(condition, message)
inline def ensure[A](condition: Boolean, message: =>A): Unit = scala.Predef.assert(condition, message)

//User-defined data and functions

lazy val N_0: Nat = nat(0)
lazy val N_1: Nat = nat(1)
lazy val Z_0: Zat = zat_of_nat(N_0)
lazy val Z_1: Zat = zat_of_nat(N_1)


def nat_max(a: Nat, b: Nat): Nat =
  if (a >= b) then
    a
  else
    b
  end if

end nat_max //(a: Nat, b: Nat): Nat

def leftpad(s: String, n: Nat, c: Char): String =
  val cs: String = char_to_str(c)
  val ps: String = str_concat(cs, s)
  if (str_len(s) >= n) then
    s
  else
    leftpad(ps, n, c)
  end if

end leftpad //(s: String, n: Nat, c: Char): String

//+ Pre-conditions for leftpad
inline def leftpad_pre_cond1(s: String, n: Nat, c: Char): Unit =
  val n_upper_value: Nat = n
  val n_lower_value: Nat = nat(0)
  require(
    (n_upper_value >= n_lower_value),
    "require(n_upper_value >= n_lower_value)"
  )

end leftpad_pre_cond1 //(s: String, n: Nat, c: Char): Unit
//- Pre-conditions for leftpad

//+ Post-conditions for leftpad
inline def leftpad_post_cond1(s: String, n: Nat, c: Char, result: String): Unit =
  val res_length: Nat = str_len(result)
  val s_length: Nat = str_len(s)
  ensure(
    (res_length == nat_max(n, s_length)),
    "ensure(res_length == nat_max(n, s_length))"
  )

end leftpad_post_cond1 //(s: String, n: Nat, c: Char, result: String): Unit

inline def leftpad_post_cond2(s: String, n: Nat, c: Char, result: String): Unit =
  val lower: Nat = nat(0)
  val pad_length: Nat = nat_max(N_0, (n - str_len(s)))
  val upper: Nat = pad_length
  // ForLoopT(extra_length,RefExprT(BindT(lower: NatT(0))),RefExprT(BindT(upper: BindT(pad_length: App2T(_: Nat)))),Exclusive,List(ValDefT(NameType(result_i,CharTy),CallExprT(RefExprT(BindT(str_char_at: StringCharAtT(_: Char))),List(),List(RefExprT(BindT(result: ParamT(result: String))), RefExprT(BindT(extra_length: ParamT(extra_length: Nat))))),false), EnsureT(CallExprT(RefExprT(BindT(char_eq: CharEqT(_: Bool))),List(),List(RefExprT(BindT(c: ParamT(c: Char))), RefExprT(BindT(result_i: StringCharAtT(_: Char))))))))
  for extra_length <- lower until upper do
    val result_i: Char = str_char_at(result, extra_length)

    ensure(
      char_eq(c, result_i),
      "ensure(char_eq(c, result_i))"
    )
  end for

end leftpad_post_cond2 //(s: String, n: Nat, c: Char, result: String): Unit

inline def leftpad_post_cond3(s: String, n: Nat, c: Char, result: String): Unit =
  val lower: Nat = nat(0)
  val upper: Nat = str_len(s)
  // ForLoopT(extra_length,RefExprT(BindT(lower: NatT(0))),RefExprT(BindT(upper: StringLenT(ParamT(s: String)))),Exclusive,List(ValDefT(NameType(pad_length,NatTy),CallExprT(RefExprT(BindT(nat_max: Fun2T(_: (Nat, Nat) => Nat))),List(),List(RefExprT(BindT(N_0: NatT(0))), BinOpExprT(SubOp,RefExprT(BindT(n: ParamT(n: Nat))),CallExprT(RefExprT(BindT(str_len: StringLenT(ParamT(s: String)))),List(),List(RefExprT(BindT(s: ParamT(s: String)))))))),false), ValDefT(NameType(index,NatTy),RefExprT(BindT(extra_length: ParamT(extra_length: Nat))),false), EnsureT(CallExprT(RefExprT(BindT(char_eq: CharEqT(_: Bool))),List(),List(CallExprT(RefExprT(BindT(str_char_at: StringCharAtT(_: Char))),List(),List(RefExprT(BindT(result: ParamT(result: String))), BinOpExprT(AddOp,RefExprT(BindT(pad_length: App2T(_: Nat))),RefExprT(BindT(extra_length: ParamT(extra_length: Nat)))))), CallExprT(RefExprT(BindT(str_char_at: StringCharAtT(_: Char))),List(),List(RefExprT(BindT(s: ParamT(s: String))), RefExprT(BindT(index: ParamT(extra_length: Nat))))))))))
  for extra_length <- lower until upper do
    val pad_length: Nat = nat_max(N_0, (n - str_len(s)))
    val index: Nat = extra_length

    ensure(
      char_eq(str_char_at(result, (pad_length + extra_length)), str_char_at(s, index)),
      "ensure(char_eq(str_char_at(result, (pad_length + extra_length)), str_char_at(s, index)))"
    )
  end for

end leftpad_post_cond3 //(s: String, n: Nat, c: Char, result: String): Unit
//- Post-conditions for leftpad
